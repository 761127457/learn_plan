我这两天打算研究一下vi的源码（就是linux上面的那个vi），然后在这个学期的课程设计中写一个简单的文本编辑器。我发现vi源码中是利用select来监听是否有输入内容的。

文件描述符
我们都知道linux里面是万物皆文件，在所有的文件描述符中有两个比较特殊的存在：0、1
其实stdin == 0，stdout == 1
所以我们可以将0设置为select要监听的文件描述符（套接字）

屏蔽回显
windows中有一个函数 getch() （不止一次别人和我说这个函数已经被淘汰，但是我觉得很有用），这个函数的作用就是直接读取键盘输入的内容，同时屏幕上不需要输出（回显），但是linux中没有这个函数（可见不是标准库函数），所以我们需要自己设置一下
这里要用到一个头文件：termios.h
// 禁止回显
    struct termios term_orig, term_vi;
    tcgetattr(0, &term_orig);
	term_vi = term_orig;
	term_vi.c_lflag &= (~ICANON & ~ECHO);	// leave ISIG ON- allow intr's
	term_vi.c_iflag &= (~IXON & ~ICRNL);
	term_vi.c_oflag &= (~ONLCR);
#ifndef linux
	term_vi.c_cc[VMIN] = 1;
	term_vi.c_cc[VTIME] = 0;
#endif
	tcsetattr(0, TCSANOW, &term_vi);
在执行上述语句后，就会禁止输入的回显，但是这样做的话会出现有一无法解决问题，那就是回车的时候会将行首定位到上一行的最后一个字符的后面，也就是说虽然是换行了，但是并没有顶格，有点html里面给div设置了float:left属性之后没有clear一样的效果。

定位光标
出现了上面的问题后，我的解决方法是直接移动光标的位置，windows有API函数可以直接拿来移动光标的位置，而在linux中是通过特殊的控制字符。
比如 printf("\033[3;3H");
执行了这句之后，光标就会定位到屏幕第三行、第三列的位置。值得注意的是\033[3:3H中的那个是分号，不是冒号

源码
/*********************************************************
 * Author           : crazy_mad
 * Last modified    : 2016-12-20 19:12
 * Filename         : main.cpp
 * Description      : 利用select监听键盘文件描述符
 *********************************************************/
 
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <termios.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <arpa/inet.h>
 
#include <iostream>
#include <algorithm>
 
using namespace std;
 
int main(int argc, char* argv[])
{
    char buf[256];
 
    // 禁止回显
    struct termios term_orig, term_vi;
    tcgetattr(0, &term_orig);
	term_vi = term_orig;
	term_vi.c_lflag &= (~ICANON & ~ECHO);	// leave ISIG ON- allow intr's
	term_vi.c_iflag &= (~IXON & ~ICRNL);
	term_vi.c_oflag &= (~ONLCR);
#ifndef linux
	term_vi.c_cc[VMIN] = 1;
	term_vi.c_cc[VTIME] = 0;
#endif
	tcsetattr(0, TCSANOW, &term_vi);
 
    fd_set readfd;
    struct timeval tv;
    //struct input_event event_kb;
    FD_ZERO(&readfd);
    FD_SET(0, &readfd);
    tv.tv_sec = 0;
    tv.tv_usec = 50000;
    while (select(0, &readfd, NULL, NULL, &tv) >= 0) {
        int i = read(0, buf, sizeof(buf));
        buf[i] = 0;
        if (i > 0) {
            //printf("%c\n", buf[0]);
            write(1, buf, strlen(buf));
        } 
        if (buf[0] == 'q') {
            break;
        }
    }
    strcpy(buf, "\033[4;0Haaaa");
    write(1, buf, strlen(buf));
    tcsetattr(0, TCSANOW, &term_orig);
 
 
    return 0;
}
————————————————
版权声明：本文为CSDN博主「crazy智障大师mad」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_32685139/article/details/53769405